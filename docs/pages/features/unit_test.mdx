## Unit Test Generator

Automatically create comprehensive unit tests for your code, improving code quality and test coverage.

### Key Features:

1. **Unit Test Generation**: The feature analyzes the code changes and generates comprehensive unit tests, covering various scenarios and edge cases.

2. **Test Coverage**: The generated tests cover a wide range of scenarios, including edge cases, boundary conditions, and exception handling.

3. **Test Execution**: The tests can be executed locally or integrated into a CI/CD pipeline for automated testing.

4. **Test Reporting**: The feature provides detailed reports, including test results, coverage statistics, and any issues or failures encountered during execution.

5. **Continuous Integration**: The generated tests can be updated or regenerated as the codebase evolves, ensuring they remain aligned with the latest changes and requirements.

## Usage Guide:

Here's a detailed step-by-step guide on how to use the Unit Test Generator:

1. Create and activate a virtual environment:

   **Mac/Linux**

   ```bash
   python3 -m venv venv
   source venv/bin/activate
   ```

   **Windows**

   ```bash
   python -m venv venv
   .\venv\Scripts\activate
   ```

2. Install poetry and Kaizen:

   ```bash
   pip install poetry kaizen-cloudcode
   ```
3. Create a new Python file and import the UnitTestGenerator module from Kaizen package :

   ```python
   from kaizen.generator.unit_test import UnitTestGenerator
   generator = UnitTestGenerator()
   ```

4. Provide the source code file or directory path for which you want to generate unit tests:  

   You can run it for one file at a time:

   ```python
   generator.generate_tests(
    file_path="path/to/your/file.py"
   )
   ```

   Or for a directory of files:

   ```python
   generator.generate_tests_from_dir(
    dir_path="path/to/your/directory"
   )
   ```

5. Optionally, you can configure output path, verbosity, and critique settings.

   ```python
   ...
    output_path="path/to/your/directory",
    enable_critique=True,
    verbose=True,
    max_critique=1
   ...
   ```

6. Run the generator to create unit tests.
   ```python
   generator.run_tests()
   ```
7. Display the test results:
   ```python
   for file_path, result in test_results.items():
       print(f"Results for {file_path}:")
       if "error" in result:
           print(f"  Error: {result['error']}")
       else:
           print(f"  Tests run: {result.get('tests_run', 'N/A')}")
           print(f"  Failures: {result.get('failures', 'N/A')}")
           print(f"  Errors: {result.get('errors', 'N/A')}")
       print()
   ```
8. Review and integrate the generated tests into your test suite.

### Example:

Here's a complete example to generate unit tests for a specific file:

```python
from kaizen.generator.unit_test import UnitTestGenerator

# Create an instance of the generator
generator = UnitTestGenerator()

# Generate tests for a specific file
generator.generate_tests(
    file_path="kaizen/helpers/output.py",
    enable_critique=True,
    verbose=True
)

# Run the generated tests
test_results = generator.run_tests()

# Display the test results
for file_path, result in test_results.items():
    print(f"Results for {file_path}:")
    if "error" in result:
        print(f"  Error: {result['error']}")
    else:
        print(f"  Tests run: {result.get('tests_run', 'N/A')}")
        print(f"  Failures: {result.get('failures', 'N/A')}")
        print(f"  Errors: {result.get('errors', 'N/A')}")
    print()
```

### Supported Languages:

- Python (.py)
- JavaScript (.js)
- TypeScript (.ts)
- React (.jsx, .tsx)
- Rust (.rs)

## How it Works:

- Input the source code or directory for which you want to generate unit tests.
- The Unit Test Generator leverages advanced language models to analyze the code and generate appropriate unit tests in a format compatible with popular testing frameworks.
- The generator supports multiple programming languages and can handle entire directories of code files.

![Unit Test Generation Algo](/unit_test_generation_algo.png)

You can find an example [here](https://github.com/Cloud-Code-AI/kaizen/tree/main/examples/unittest/main.py)

## API Reference:

### Class: UnitTestGenerator

#### Constructor

- `__init__(self, verbose=False)`
  Initializes the UnitTestGenerator with optional verbosity setting.

#### Methods

##### generate_tests_from_dir

- `generate_tests_from_dir(self, dir_path: str, output_path: str = None)`
  Generates unit tests for all supported files in a given directory.
  - Parameters:
    - `dir_path`: Path of the directory containing source files.
    - `max_critique`: Maximum number of critique iterations.
    - `output_path`: (Optional) Custom output path for generated tests.
    - `verbose`: Enable verbose logging.
    - `enable_critique`: Enable AI critique and improvement of generated tests.
  - Returns: A tuple containing an empty dictionary and llm usage statistics.

##### generate_tests

- `generate_tests(self, file_path: str, content: str = None, max_critique: int = 3, output_path: str = None, verbose: bool = False, enable_critique: bool = False)`
  Generates unit tests for a given file with various configuration options.
  - Parameters:
    - `file_path`: Path of the file relative to the project root.
    - `content`: (Optional) File content.
    - `max_critique`: Maximum number of critique iterations.
    - `output_path`: (Optional) Custom output path for generated tests.
    - `verbose`: Enable verbose logging.
    - `enable_critique`: Enable AI critique and improvement of generated tests.
  - Returns: A tuple containing an empty dictionary and llm usage statistics.

##### run_tests

- `run_tests(self) -> Dict`
  Runs the generated unit tests and returns the results.

## Benefits:

- Increased Test Coverage
- Time Efficiency
- Consistency in Testing
- Early Bug Detection
- Support for Multiple Programming Languages
- Continuous Improvement through AI Critique

## Limitations:

- AI Limitations: May not cover all edge cases or complex scenarios.
- Human Oversight: Generated tests should be reviewed and potentially modified by developers.
- Language Support: Limited to the supported programming languages.